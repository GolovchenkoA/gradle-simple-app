//import org.openapitools.generator.gradle.plugin.tasks.GenerateTask
import org.example.*
import org.openapitools.generator.gradle.plugin.tasks.GenerateTask


/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.6/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    alias(libs.plugins.jvm)

    // Apply the application plugin to add support for building a CLI application in Java.
    application
//    id("org.example.openapi-gradle-plugin")
    id("openapi-plugin") version "0.0.16"
//    id("org.openapi.generator")


    // if it does not have a version see settings.gradle.
    id("org.example.git-plugin")
//    id("org.example.git-plugin") version "0.0.2"

}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenLocal()
    mavenCentral()
}

dependencies {
    // Use the Kotlin JUnit 5 integration.
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")

    // Use the JUnit 5 integration.
    testImplementation(libs.junit.jupiter.engine)

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation(libs.guava)
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    // Define the main class for the application.
    mainClass = "org.example.AppKt"
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}

tasks.register<Task>("create file task custom") {
    group = "My OpenAPI generator"
//    val basePath = project.layout.buildDirectory.dir("generated-folder").get().asFile.toPath()
//    basePath.createDirectory()

//    var fileName = "myfile.txt"
//    var filePath = project.layout.buildDirectory.dir("generated-folder").get().asFile.toPath()
//    Files.createDirectory(filePath)
//    var myFile: File = File(filePath.toFile(), fileName)
//    myFile.createNewFile()
//    myFile.writeText("some text")
}


// Original Open Api task
//tasks.named<GenerateTask>("openApiGenerate") {
//    group = "this project tasks"
//
////    inputSpec = layout.projectDirectory.file("src\\main\\resources\\openapi.yml").asFile.absolutePath
//    inputSpec = ".\\src\\main\\resources\\openapi.yml" // !! it works
//
// // path: app\openapi\openapi.yml
////    inputSpec = layout.projectDirectory.file("openapi\\openapi.yml").asFile.absolutePath
//
//generatorName = "java"
//}

// it has name 'greeting2' because a task with name 'greeting' is already registered in my OpenApiPluginPlugin
tasks.register<Greeting>("greeting2") {
    group = "greeting"
    greeting.set("Hi")
    greeting = "Hi 2"

    doFirst{
        println("Message(doFirst) is: ${message.get()}")
    }

    doLast {
        println("Message(doLast) is: ${message.get()}")
    }
}

/////////////////////////////////////////////////////////////////
// Create the source generation task
tasks.register<GenerateSource>("generate") {
    group = "this project tasks"
    // Configure the locations, relative to the project and build directories
    configFile = layout.projectDirectory.file("src/config.txt")
    outputDir = layout.buildDirectory.dir("generated-source")
}

// Change the build directory
// Don't need to reconfigure the task properties. These are automatically updated as the build directory changes
layout.buildDirectory = layout.projectDirectory.dir("output")
/////////////////////////////////////////////////////////////////


/////////////////////Producer-Consumer example 1////////////////////////////////////////////
val producer = tasks.register<Producer>("producer")
val consumer = tasks.register<Consumer>("consumer")

consumer {
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    inputFile = producer.flatMap { it.outputFile }
}

producer {
    // Set values for the producer lazily
    // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
    outputFile = layout.buildDirectory.file("file.txt")
}

// Change the build directory.
// Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes
layout.buildDirectory = layout.projectDirectory.dir("output")
/////////////////////////////////////////////////////////////////

/////////////////////Producer-Consumer example 2////////////////////////////////////////////
// source: https://docs.gradle.org/current/userguide/lazy_configuration.html
val producer2 = tasks.register<Producer>("producer2") {
    // Set values for the producer lazily
    // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
    outputFile = layout.buildDirectory.file("file.txt")
}
tasks.register<Consumer2>("consumer2") {
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    message = producer2.flatMap { it.outputFile }.map { it.asFile.readText() }
}
//////////////////////////Default value example///////////////////////////////////////
tasks.register("show") {
    val property = objects.property(String::class)

    // Set a convention
    property.convention("convention 1")

    println("value = " + property.get())

    // Can replace the convention
    property.convention("convention 2")
    println("value = " + property.get())

    property.set("explicit value")

    // Once a value is set, the convention is ignored
    property.convention("ignored convention")

    doLast {
        println("value = " + property.get())
    }
}
////////////////////Unmodifiable properties/////////////////////////////////////////////
// source: https://docs.gradle.org/current/userguide/lazy_configuration.html
// see also: https://docs.gradle.org/current/userguide/lazy_configuration.html#lazy_configuration_reference
// libVersioning.version.finalizeValue()
//modifiedFiles.finalizeValueOnRead()
/////////////////////////////////////////////////////////////////

// Worker API (parallel tasks)
// https://docs.gradle.org/current/userguide/worker_api.html

// Incremental tasks
// https://docs.gradle.org/current/userguide/custom_tasks.html

// Windows vs Linux
// https://docs.gradle.org/current/userguide/custom_tasks.html
// PathSensitive(PathSensitivity.NAME_ONLY)


// Command Line Options
// https://docs.gradle.org/current/userguide/custom_tasks.html#sec:declaring_and_using_command_line_options
// @Option(option = "url", description = "Configures the URL to be verified.")


// My Custom Open Api task
// v1
tasks.`generate-openapi-classes` {
//    dependsOn(tasks.named("test"))
//    dependsOn("test")
}

// v2kotlin-spring
//tasks.named<GenerateTask>("openApiGenerate") {
//    generatorName = "kotlin-spring"
//}
tasks.named<GenerateTask>("openApiGenerate") {
//    group = "openapi tools custom"
    generatorName = "kotlin-spring"
}

//tasks.register("generateClient", GenerateTask::class.java) {
//tasks.named("openApiGenerate", GenerateTask::class.java) {
////    group = "this project tasks"
////    inputSpec = ".\\src\\main\\resources\\openapi.yml" // doesn't work
////    inputSpec = layout.projectDirectory.file("src\\main\\resources\\openapi.yml").asFile.absolutePath
////    generatorName = "java"
//    outputDir = project.layout.buildDirectory.dir("dist3").get().asFile.absolutePath
////    enablePostProcessFile = true
//}


//tasks.withType<GenerateTask>() {
////    inputSpec = file("src/main/resources/openapi.yml").path.toString()
//    inputSpec = "C:\\Users\\aholovchenko\\IdeaProjects\\gradle-simple-app\\app\\src\\main\\resources\\openapi.yml"
//}


// Run: gradlew -Pprop1=p1 printMessage
// or   gradlew printMessage -Pprop1=p1
tasks.register("printMessage") {
    if(project.hasProperty("prop1")) {
        println("Prop 1 value is: ${project.property("prop1")}")
    }

    //comment for branch 1
    //comment for branch 2
}